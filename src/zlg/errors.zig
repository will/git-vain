const std = @import("std");
const c = @import("internal/c.zig");
const internal = @import("internal/internal.zig");
const log = std.log.scoped(.git);

const git = @import("git.zig");

pub const GitError = error{
    /// Generic error
    GenericError,
    /// Requested object could not be found
    NotFound,
    /// Object exists preventing operation
    Exists,
    /// More than one object matches
    Ambiguous,
    /// Output buffer too short to hold data
    BufferTooShort,
    /// A special error that is never generated by libgit2 code.  You can return it from a callback (e.g to stop an iteration)
    /// to know that it was generated by the callback and not by libgit2.
    User,
    /// Operation not allowed on bare repository
    BareRepo,
    /// HEAD refers to branch with no commits
    UnbornBranch,
    /// Merge in progress prevented operation
    Unmerged,
    /// Reference was not fast-forwardable
    NonFastForwardable,
    /// Name/ref spec was not in a valid format
    InvalidSpec,
    /// Checkout conflicts prevented operation
    Conflict,
    /// Lock file prevented operation
    Locked,
    /// Reference value does not match expected
    Modifed,
    /// Authentication error
    Auth,
    /// Server certificate is invalid
    Certificate,
    /// Patch/merge has already been applied
    Applied,
    /// The requested peel operation is not possible
    Peel,
    /// Unexpected EOF
    EndOfFile,
    /// Invalid operation or input
    Invalid,
    /// Uncommitted changes in index prevented operation
    Uncommited,
    /// The operation is not valid for a directory
    Directory,
    /// A merge conflict exists and cannot continue
    MergeConflict,
    /// A user-configured callback refused to act
    Passthrough,
    /// Signals end of iteration with iterator
    IterOver,
    /// Internal only
    Retry,
    /// Hashsum mismatch in object
    Mismatch,
    /// Unsaved changes in the index would be overwritten
    IndexDirty,
    /// Patch application failed
    ApplyFail,
};

/// Transform a `GitError` into the matching `libgit2` error code
pub fn errorToCInt(err: GitError) c_int {
    return switch (err) {
        git.GitError.GenericError => c.GIT_ERROR,
        git.GitError.NotFound => c.GIT_ENOTFOUND,
        git.GitError.Exists => c.GIT_EEXISTS,
        git.GitError.Ambiguous => c.GIT_EAMBIGUOUS,
        git.GitError.BufferTooShort => c.GIT_EBUFS,
        git.GitError.User => c.GIT_EUSER,
        git.GitError.BareRepo => c.GIT_EBAREREPO,
        git.GitError.UnbornBranch => c.GIT_EUNBORNBRANCH,
        git.GitError.Unmerged => c.GIT_EUNMERGED,
        git.GitError.NonFastForwardable => c.GIT_ENONFASTFORWARD,
        git.GitError.InvalidSpec => c.GIT_EINVALIDSPEC,
        git.GitError.Conflict => c.GIT_ECONFLICT,
        git.GitError.Locked => c.GIT_ELOCKED,
        git.GitError.Modifed => c.GIT_EMODIFIED,
        git.GitError.Auth => c.GIT_EAUTH,
        git.GitError.Certificate => c.GIT_ECERTIFICATE,
        git.GitError.Applied => c.GIT_EAPPLIED,
        git.GitError.Peel => c.GIT_EPEEL,
        git.GitError.EndOfFile => c.GIT_EEOF,
        git.GitError.Invalid => c.GIT_EINVALID,
        git.GitError.Uncommited => c.GIT_EUNCOMMITTED,
        git.GitError.Directory => c.GIT_EDIRECTORY,
        git.GitError.MergeConflict => c.GIT_EMERGECONFLICT,
        git.GitError.Passthrough => c.GIT_PASSTHROUGH,
        git.GitError.IterOver => c.GIT_ITEROVER,
        git.GitError.Retry => c.GIT_RETRY,
        git.GitError.Mismatch => c.GIT_EMISMATCH,
        git.GitError.IndexDirty => c.GIT_EINDEXDIRTY,
        git.GitError.ApplyFail => c.GIT_EAPPLYFAIL,
    };
}

pub const DetailedError = extern struct {
    raw_message: [*:0]const u8,
    class: ErrorClass,

    pub const ErrorClass = enum(c_int) {
        none = 0,
        no_memory,
        os,
        invalid,
        reference,
        zlib,
        repository,
        config,
        regex,
        odb,
        index,
        object,
        net,
        tag,
        tree,
        indexer,
        ssl,
        submodule,
        thread,
        stash,
        checkout,
        fetchhead,
        merge,
        ssh,
        filter,
        revert,
        callback,
        cherrypick,
        describe,
        rebase,
        filesystem,
        patch,
        worktree,
        sha1,
        http,
        internal,
    };

    pub fn message(self: DetailedError) [:0]const u8 {
        return std.mem.sliceTo(self.raw_message, 0);
    }

    test {
        try std.testing.expectEqual(@sizeOf(c.git_error), @sizeOf(DetailedError));
        try std.testing.expectEqual(@bitSizeOf(c.git_error), @bitSizeOf(DetailedError));
    }

    comptime {
        std.testing.refAllDecls(@This());
    }
};

comptime {
    std.testing.refAllDecls(@This());
}
